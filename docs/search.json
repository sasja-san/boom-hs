[
  {
    "objectID": "01_elem.html",
    "href": "01_elem.html",
    "title": "1. Babys First Haskell Functions",
    "section": "",
    "text": "Let’s start with looking at two versions of the same thing. Hopefully this can be a bridge between what you know and the style Haskell uses: Hint: You can click the numbers in the list below and have the corresponding code be highlighted.\nLet’s look at elem:\nSo what’s the type of elem? Run ghci&gt; :t elem and you should get this:\nSmall letters, especially the a correspond to the generic type, like &lt;T&gt; in languages like Java or C++. In this particular case the generic type t (with a restriction Foldable t) represents a structure. So the t could be replaced with List or Set or Seq or many other types.\nLet’s simplify this by forcing the Foldable into a list. This gives us:\nNow that’s A LOT better. It says that the element a has to have the Eq trait/interface.1 This means that the functions == and != has to be defined for a. If it does, then we can search for something of type a in a [a] (“list of a:s”) and we will get back a Bool.\nLet’s now get back to myElem.\nThat’s a bit better. Now you check against the first element of the list. But what if the call is elem 'b' \"abc\", then you’ll crash because you used undefined2. Here’s where you have to bring in recursion, so this is the complete function definition:\nIt’s a bit verbose, so given that “or” is defined as this:\nTrying it out in ghci:\nLet’s use it for our myElem function!"
  },
  {
    "objectID": "01_elem.html#tutorial-structure-your-first-function",
    "href": "01_elem.html#tutorial-structure-your-first-function",
    "title": "1. Babys First Haskell Functions",
    "section": "Tutorial Structure / Your First Function",
    "text": "Tutorial Structure / Your First Function\nThis tutorial will asks you to write your own version of existing library functions. In this first instance you will write myElem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool. So it has the same type as the library one, just my in front of it, to avoid naming conflicts.\nCreate a file Exercise.hs which looks like this:\n1import Data.List\n2import Data.Char\n\n3myElem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool\n4myElem e []     = False\n5myElem e (x:xs) = undefined\n\n1\n\nGet all the list functions available in your terminal.\n\n2\n\nWe will need some extra functions for Char manipulation.\n\n3\n\nDeclaration of the type of the function myElem. All things of type a needs to be able to do ==. It takes an a, a list of a and returns a Bool.\n\n4\n\nThe “base case”. When looking for the element e in an empty list, we won’t find it. So we return False.\n\n5\n\nThis is where you’ll put your recursive call.\n\n\nNow complete the function at the last line. Haskell is quite squeamish about indentation, so you might get a few compilation errors before you get it right.\nHere’s an example of correct indentation for if, which also uses the let-in notation for local variable creation:"
  },
  {
    "objectID": "01_elem.html#writing-conventions",
    "href": "01_elem.html#writing-conventions",
    "title": "1. Babys First Haskell Functions",
    "section": "Writing Conventions",
    "text": "Writing Conventions\nWhen making “alternate” version of existing values you usually stick a ' at the end. So in this case the string s1 becomes s1', pronounced as [s one prime] (swedish: [prim]). The contents of s1' and s2' is the same as s1 and s2 except that any characters not in lower case has been turned into lower case."
  },
  {
    "objectID": "01_elem.html#your-new-best-friend",
    "href": "01_elem.html#your-new-best-friend",
    "title": "1. Babys First Haskell Functions",
    "section": "Your New Best Friend",
    "text": "Your New Best Friend\nIf you’ve ever used Python you just put in your expression in the prompt and get the resulting value and side effects (such as file I/O & whatnot).\nHaskell is extremely strict regarding its types. When a Python program will run and crash because of a programmer error, a Haskell program refuses to load in the first place.\nTo look a bit at what’s going on here, in ghci try using the :t command. It asks for the type of an expression. First ask about map:\n  ghci&gt; :t map\nThe part (a -&gt; b) means that the first argument is a function, taking something of type a and returning something of type b.\nNow let’s play with it a bit:\n\n\n\n  ghci&gt; :t toLower\n  ghci&gt; :t toLower 'A'\n  ghci&gt; toLower 'A'\n  ghci&gt; :t map toLower\nBecause toLower has the type you saw (when running the above commands in ghci), those types gets bound up in map.\nUsing :t will be one of your primary tools for learning Haskell."
  },
  {
    "objectID": "01_elem.html#fking-around-with-t---finding-out",
    "href": "01_elem.html#fking-around-with-t---finding-out",
    "title": "1. Babys First Haskell Functions",
    "section": "F**king Around With :t - Finding Out",
    "text": "F**king Around With :t - Finding Out\nFirst let’s look at the function length and then write our own, just to get away from the Foldable nonsense.\nghci&gt; :t length\nlength :: (Foldable t) =&gt; t a -&gt; Int\nNow make your own:\n\nBehaviorImplementation\n\n\nghci&gt; :t myLength\nmyLength :: [a] -&gt; Int\nghci&gt; myLength []\n0\nghci&gt; myLength \"\"\n0\nghci&gt; myLength [1..5]\n5\nghci&gt; myLength \"abc123\"\n6\n\n\nmyLength        :: [a] -&gt; Int\nmyLength    []  = 0\nmyLength (_:xs) = 1 + myLength xs\n\n\n\nAnd also make one that enforces the String type.\n\nBehaviorImplementation\n\n\nghci&gt; :t myStringLength\nmyLength :: String -&gt; Int\nghci&gt; myLength \"\"\n0\nghci&gt; myLength \"1234\"\n4\nghci&gt; myLength [1..5]\n\n&lt;interactive&gt;:76:17: error:\n    • No instance for (Num Char) arising from the literal ‘1’\n    • In the expression: 1\n      In the first argument of ‘myStringLength’, namely ‘[1 .. 4]’\n      In the expression: myStringLength [1 .. 4]\n\n\nmyStringLength    :: String -&gt; Int\nmyStringLength cs = myLength cs\n\n\n\nLet’s look at map again, which in many cases acts as your foreach function.\nghci&gt; :t map\nmap :: (a -&gt; b) -&gt; [a] -&gt; [b]\nNow, BEFORE asking ghci about the type of the below expression, can you figure out what it will be? It’s a matter of search-and-replace with the types that comes from the first argument to map.\n\nQueryAnswer\n\n\nghci&gt; :t map myStringLength\n\n\nmap myStringLength :: [String] -&gt; [Int]\n\n\n\nYou could write a list of strings manually, which is kind of annoying:\n[\"my\", \"list\", \"of\", \"strings\"]\nInstead, try using the function words.\nghci&gt; :t words\nwords :: String -&gt; [String]\nghci&gt; words \"hello everyone reading\"\n[\"hello\",\"everyone\",\"reading\"]\nNow combine map myStringLength with words into something computable. You will need to put parenthenses at the right place for this to work.\n\nNow you have the most basic tools for learning Haskell."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Boom-HS Starting Page",
    "section": "",
    "text": "This is intended as a short and simple way for someone who has a bit of programming experience1 to start at the right end of learning Haskell.2\n1 Mostly made for people doing the AI course at Jönköpings Tekniska Högskola (JTH).2 There’s way too many “What is a Monad?” tutorials out there. Don’t even fuck around with those for your first month. It will be a huge waste of your time.To reach basic proficiency you will need to master three things.\n\nThe basic syntax of lists and datatypes.\nUnderstanding and writing function type signatures.\nSome/most of the functions in Prelude.hs.\n\nThis tutorial aims to guide you through these with minimal effort."
  },
  {
    "objectID": "index.html#about-this-tutorial",
    "href": "index.html#about-this-tutorial",
    "title": "Boom-HS Starting Page",
    "section": "",
    "text": "This is intended as a short and simple way for someone who has a bit of programming experience1 to start at the right end of learning Haskell.2\n1 Mostly made for people doing the AI course at Jönköpings Tekniska Högskola (JTH).2 There’s way too many “What is a Monad?” tutorials out there. Don’t even fuck around with those for your first month. It will be a huge waste of your time.To reach basic proficiency you will need to master three things.\n\nThe basic syntax of lists and datatypes.\nUnderstanding and writing function type signatures.\nSome/most of the functions in Prelude.hs.\n\nThis tutorial aims to guide you through these with minimal effort."
  },
  {
    "objectID": "index.html#install-ghc",
    "href": "index.html#install-ghc",
    "title": "Boom-HS Starting Page",
    "section": "Install GHC",
    "text": "Install GHC\nIf you have a package manager, preferably use that. It’s around 500 MB. The package name is usually just ghc.\nIf you don’t have one use Stack but that’ll take almost 2 GB.\nIf you’re on Windows then you shouldn’t be using this tutorial. You’re too far outside the programmer culture in general for this to help you. Is there any real chance for you to save your soul? Repent and better your ways.3\n3 Stack has instructions for Windows as well."
  },
  {
    "objectID": "index.html#tutorial-name",
    "href": "index.html#tutorial-name",
    "title": "Boom-HS Starting Page",
    "section": "Tutorial Name",
    "text": "Tutorial Name\n\nHaskell files have the extension .hs. “HS” is also short for something else, as seen in this video. Coincidentally, at the end of the linked video you can see the average student reaction as he tries to learn Haskell."
  },
  {
    "objectID": "02_my_funs.html",
    "href": "02_my_funs.html",
    "title": "2. The List of Functions",
    "section": "",
    "text": "Once you’ve gone through the basic tools as part of Part 1 you should have what it takes to complete this.\nIt’s a list of functions, pretty much all from the module Data.List which you should write your own versions of."
  },
  {
    "objectID": "02_my_funs.html#the-list",
    "href": "02_my_funs.html#the-list",
    "title": "2. The List of Functions",
    "section": "The List",
    "text": "The List\n\nelemSource\n\n\nghci&gt; elem 1 [0,2..10]\nFalse\nghci&gt; elem 'b' \"abc\"\nTrue\n\n\nelem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool\nelem _    []  = False\nelem e (x:xs) = (e == x) || myElem e xs\n\n\n\n\nlengthsource\n\n\nghci&gt; length \"\"\n0\nghci&gt; length []\n0\nghci&gt; length \"hej du glade\"\n12\nghci&gt; length (words \"hej du glade\")\n3\n\n\nlength :: [a] -&gt; Int\nlength    []  = 0\nlength (_:xs) = 1 + myLength xs\n\n\n\n\nnullsource\n\n\nghci&gt; null []\nTrue\nghci&gt; null \"\"\nTrue\nghci&gt; null [1..]\nFalse\nghci&gt; null \"abc\"\nFalse\n\n\nnull             :: [a] -&gt; Bool\nnull []          =  True\nnull (_:_)       =  False\n\n\n\n\nheadsource\n\n\nghci&gt; head [1..]\n1\nghci&gt; head \"abc\"\n'a'\nghci&gt; head []\n*** Exception: Prelude.head: empty list\n\n\nhead             :: [a] -&gt; a\nhead (x:_)       =  x\nhead []          =  error \"Prelude.head: empty list\"\n\n\n\n\ntailsource\n\n\nghci&gt; tail [1..]\n[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,Interrupted.\nghci&gt; tail []\n*** Exception: Prelude.tail: empty list\nghci&gt; tail [42]\n[]\nghci&gt; tail [42, 69]\n[69]\n\n\ntail             :: [a] -&gt; [a]\ntail (_:xs)      =  xs\ntail []          =  error \"Prelude.tail: empty list\"\n\n\n\n\nlastsource\n\n\nghci&gt; last \"abc\"\n'c'\nghci&gt; last []\n*** Exception: Prelude.last: empty list\n\n\nlast             :: [a] -&gt; a\nlast [x]         =  x\nlast (_:xs)      =  last xs\nlast []          =  error \"Prelude.last: empty list\""
  },
  {
    "objectID": "02_my_funs.html#the-maybe-detour",
    "href": "02_my_funs.html#the-maybe-detour",
    "title": "2. The List of Functions",
    "section": "The Maybe Detour",
    "text": "The Maybe Detour\nHaskell has a type called Maybe. It’s one way you could do null values in Haskell, as NULL isn’t exactly a valid value in the language. It’s defined as\n\n\nRead the declaration as\n\nThe datatype Maybe is either Nothing or it’s Just a, were a is some contained data.\n\ndata Maybe a = Nothing | Just a\nSay that you’re trying to read a number from a String, then Maybe is great way to represent your error:\nstrToInt :: String -&gt; Maybe Int\nIf the parsing fails you get Nothing. If the parsing succeeds you get Just x, where x is the number found in the String."
  },
  {
    "objectID": "02_my_funs.html#back-to-the-list",
    "href": "02_my_funs.html#back-to-the-list",
    "title": "2. The List of Functions",
    "section": "Back to the List",
    "text": "Back to the List\n\n\n\n\n\n\n\n\nThis one is a little tricky, so be sure to read the source carefully.\n\nelemIndexsource\n\n\nghci&gt; elemIndex 5 [0..10]\nJust 5\nghci&gt; elemIndex 5 []\nNothing\nghci&gt; elemIndex 5 [6..10]\nNothing\n\n\nelemIndex :: (Eq a) =&gt; a -&gt; [a] -&gt; Maybe Int\nelemIndex e xs = ei 0 e xs\n  where\n    ei :: (Eq a) =&gt; Int -&gt; a -&gt; [a] -&gt; Maybe Int\n    ei ixCount e    []  = Nothing\n    ei ixCount e (x:xs) = if (e == x)\n                        then Just ixCount\n                        else ei (ixCount + 1) e xs\n\n\n\n\ntakesource\n\n\nghci&gt; take 0 \"abc\"\n\"\"\nghci&gt; take 5 \"abc\"\n\"abc\"\nghci&gt; take 2 (words \"foo bar baz\")\n[\"foo\",\"bar\"]\n\n\ntake                   :: Int -&gt; [a] -&gt; [a]\ntake n _      | n &lt;= 0 =  []\ntake _ []              =  []\ntake n (x:xs)          =  x : take (n-1) xs\n\n\n\n\ndropsource\n\n\nghci&gt; drop 0 \"abc\"\n\"abc\"\nghci&gt; drop 5 \"abc\"\n\"\"\nghci&gt; drop 5 [1..10]\n[6,7,8,9,10]\n\n\ndrop                   :: Int -&gt; [a] -&gt; [a]\ndrop n xs     | n &lt;= 0 =  xs\ndrop _ []              =  []\ndrop n (_:xs)          =  drop (n-1) xs\n\n\n\n\nreversesource\n\n\nghci&gt; reverse \"Jesus Christ Superstar\"\n\"ratsrepuS tsirhC suseJ\"\n\n\nreverse :: [a] -&gt; [a]\nreverse xs = rev xs []\n  where\n    rev (x:xs) acc = rev xs (x:acc)\n    rev []     acc = acc"
  },
  {
    "objectID": "02_my_funs.html#the-pairing-detour",
    "href": "02_my_funs.html#the-pairing-detour",
    "title": "2. The List of Functions",
    "section": "The Pairing Detour",
    "text": "The Pairing Detour\nIn Haskell there are “pairs” or “tuples”. They are constructed with the (,) operator/function. So\n(,) :: a -&gt; b -&gt; (a,b)\nYou can always construct a pair with paretheses and a comma.\nghci&gt; let i = 123 :: Int\nghci&gt; let p = (i, \"hello\")\nghci&gt; :t p\np :: (Int, String)\nghci&gt; p\n(123,\"hello\")\nThe “tuple” isn’t limited to two elemnts. But when you get up in numbers you really should consider using the data keyword so that your paired up data can have names for each of the fields.\nBut here it is:\nmakeTriple :: a -&gt; b -&gt; c -&gt; (a,b,c)\nmakeTriple x y z = (x,y,z)"
  },
  {
    "objectID": "02_my_funs.html#the-list-again",
    "href": "02_my_funs.html#the-list-again",
    "title": "2. The List of Functions",
    "section": "The List, Again",
    "text": "The List, Again\n\nzipsource\n\n\nghci&gt; zip [1,2,3] \"abc\"\n[(1,'a'),(2,'b'),(3,'c')]\nghci&gt; zip [1..] \"xyz\"\n[(1,'x'),(2,'y'),(3,'z')]\nghci&gt; zip [1..] [999999,999998..]\n[(1,999999),(2,999998),(3,999997),(4,999996),(5,999995),(6,999994),(7,999993),(8,99999Interrupted.\n\n\nzip    []      _    = []\nzip     _     []    = []\nzip (x:xs) (y:ys)   = (x,y) : zip xs ys\n\n\n\n\nzipWithsource\n\n\nghci&gt; zipWith (*) [1,2,3] [10, 0, 100]\n[10,0,300]\nghci&gt; zipWith (&gt;) [1,2,3] [10, 0, 100]\n[False,True,False]\n\n\nzipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]\nzipWith z (a:as) (b:bs) =  (z a b) : (zipWith z as bs)\nzipWith _     _      _  =  []\n\n\n\n\n\n\n\n\n\n\n\nTo grasp this, try using it with :t in many different ways.\nOnce you understand the source for zipWith, rewrite your function myZip by using myZipWith.\n\ntakeWhilesource\n\n\nghci&gt; takeWhile (&lt;3) [1..10]\n[1,2]\n\n\ntakeWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\ntakeWhile p []          =  []\ntakeWhile p (x:xs) \n            | p x       =  x : takeWhile p xs\n            | otherwise =  []\nUsing | is called a “guard”. It’s a fancier way of doing multiple nested if-else expressions. otherwise is an alias for True.\n\n\n\n\ndropWhilesource\n\n\nghci&gt; dropWhile (&lt;3) [1..10]\n[3,4,5,6,7,8,9,10]\n\n\ndropWhile               :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\ndropWhile p []          =  []\ndropWhile p xs@(x:xs')\n            | p x       =  dropWhile p xs'\n            | otherwise =  xs\nThe syntax with xs@(x:xs') says that you can deal with the whole list by using xs but you have also named the first element as x and the tail of the list as xs'.\n\n\n\n\nfiltersource\n\n\nghci&gt; filter isUpper \"BiG GaZOngaZ\"\n\"BGGZOZ\"\nghci&gt; filter (\\x -&gt; (x `mod` 3) == 0) [1..10]\n[3,6,9]\n\n\nfilter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]\nfilter p []                 = []\nfilter p (x:xs) | p x       = x : filter p xs\n                | otherwise = filter p xs\n\n\n\n\nmapsource\n\n\nghci&gt; map (*2) [1..3]\n[2,4,6]\nghci&gt; let ws = words \"a nice list of words\"\nghci&gt; map reverse ws\n[\"a\",\"ecin\",\"tsil\",\"fo\",\"sdrow\"]\n\n\nmap :: (a -&gt; b) -&gt; [a] -&gt; [b]\nmap _    []  = []\nmap f (x:xs) = f x : map f xs\n\n\n\n\nsumsource\n\n\nghci&gt; sum [1..100]\n5050\n\n\n{- see foldr -}\n\n\n\n\nproductsource\n\n\nghci&gt; product [3,7]\n21\n\n\n{- see foldr -}"
  },
  {
    "objectID": "02_my_funs.html#identity-elemments-of-operations",
    "href": "02_my_funs.html#identity-elemments-of-operations",
    "title": "2. The List of Functions",
    "section": "Identity Elemments of Operations",
    "text": "Identity Elemments of Operations\nConsider multiplication or addition. Both operations have an “identity element” i such that it will return the original value when applying the operation:\nx + i_add = x\nx * i_mul = x\nFor addition we have 0 as i_add. For multiplication i_mul is 1."
  },
  {
    "objectID": "02_my_funs.html#the-final-list-functions",
    "href": "02_my_funs.html#the-final-list-functions",
    "title": "2. The List of Functions",
    "section": "The Final List Functions",
    "text": "The Final List Functions\n\nfoldrsource\n\n\nghci&gt; :t foldr\nfoldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b\nghci&gt; let myNewSum = foldr (+) 0\nghci&gt; :t myNewSum\nmyNewSum :: (Num b) =&gt; [b] -&gt; b\nghci&gt; myNewSum [1..100]\n5050\n\n\nfoldr            :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b\nfoldr f z []     =  z\nfoldr f z (x:xs) =  f x (foldr f z xs)\n\n\n\n\nfoldlsource\n\n\nghci&gt; :t foldl\nfoldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b\nghci&gt; let myNewProd = foldl (*) 1\nghci&gt; :t myNewProd\nmyNewProd :: )Num a) =&gt; [a] -&gt; a\nghci&gt; myNewProd [3,7]\n21\n\n\nfoldl            :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a\nfoldl f z []     =  z\nfoldl f z (x:xs) =  foldl f (f z x) xs"
  },
  {
    "objectID": "02_my_funs.html#difficult-bonus-exercise",
    "href": "02_my_funs.html#difficult-bonus-exercise",
    "title": "2. The List of Functions",
    "section": "Difficult Bonus Exercise",
    "text": "Difficult Bonus Exercise\nImport Data.Map1 into your program and create a one-liner (or as close as you can make it) to a tree building function:\n1 The standard binary tree implementation.buildTree :: (Ord k) =&gt; [(k,v)] -&gt; Map k v\nIt should be done by using a fold with insert as its function argument."
  },
  {
    "objectID": "02_my_funs.html#identity-elements-of-operations",
    "href": "02_my_funs.html#identity-elements-of-operations",
    "title": "2. The List of Functions",
    "section": "Identity Elements of Operations",
    "text": "Identity Elements of Operations\nConsider multiplication or addition. Both operations have an “identity element” i such that it will return the original value when applying the operation:\nx + i_add = x\nx * i_mul = x\nFor addition we have 0 as i_add. For multiplication i_mul is 1."
  }
]